/*
 *  Copyright (c) 2017, salesforce.com, inc.
 *  All rights reserved.
 *  Licensed under the BSD 3-Clause license.
 *  For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */

package com.salesforce.grpc.contrib.instancemode;

import io.grpc.*;

import java.util.Collection;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

/**
 * {@code PerSessionService} forces gRPC to instantiate a fresh service implementation object for each unique client
 * session connecting to a service.
 *
 * <p>{@code PerSessionService} is useful when you want to share state between service operations on a per-session
 * basis. Each time a client {@code ManagedChannel} connects to a {@code PerSessionService}, a new service
 * implementation instance is created. This instance will be used for all calls made by the {@code ManagedChannel}, but
 * will be isolated from calls made from other clients. However, isolation comes at a cost to performance. Service
 * implementation initialization time is added to every request. If initialization is costly or time consuming, gRPC
 * throughput will noticeably degrade. Additionally, resource consumption will grow linearly with the number of
 * concurrent connections. Resource exhaustion and poor scalability will happen the service is not implemented with
 * care.
 *
 * <p>If the decorated service instance implements {@link AutoCloseable}, the instance's {@link AutoCloseable#close()}
 * method will be called when the client's connection is closed. Use this opportunity to free any shared resources.
 *
 * @param <T> a {@code BindableService} implementation to decorate
 */
public class PerSessionService<T extends BindableService> implements BindableService {
    private ServerServiceDefinition perSessionBinding;
    private Map<UUID, T> sessionServices = new ConcurrentHashMap<>();

    /**
     * Create a {@code PerSessionService} for a provided service implementation class, generated by a factory method.
     *
     * @param factory A factory that will initialize a new service implementation object for every call.
     */
    public PerSessionService(Supplier<T> factory) {
        SessionIdTransportFilter.subscribeToTerminated((o, arg) -> deactivate((UUID) arg));
        perSessionBinding = bindService(factory);
    }

    /**
     * Create a {@code PerSessionService} for a provided service implementation class. The provided class must have a
     * default constructor.
     *
     * @param clazz The service implementation class to decorate.
     */
    public PerSessionService(Class<T> clazz) {
        this (() -> {
            try {
                return clazz.newInstance();
            } catch (ReflectiveOperationException e) {
                throw new IllegalArgumentException("Class " + clazz.getName() + " must have a public default constructor", e);
            }
        });
    }

    @SuppressWarnings("unchecked")
    private ServerServiceDefinition bindService(Supplier<T> factory) {
        ServerServiceDefinition baseDefinition = factory.get().bindService();
        ServiceDescriptor descriptor = baseDefinition.getServiceDescriptor();
        Collection<ServerMethodDefinition<?, ?>> methods =  baseDefinition.getMethods();

        ServerServiceDefinition.Builder builder = ServerServiceDefinition.builder(descriptor);
        methods.forEach(method -> builder.addMethod(ServerMethodDefinition.create(method.getMethodDescriptor(), new PerSessionServerCallHandler(factory))));
        return builder.build();
    }

    @Override
    public ServerServiceDefinition bindService() {
        return perSessionBinding;
    }

    /**
     * Internal class implementing the per-session service pattern.
     */
    private class PerSessionServerCallHandler implements ServerCallHandler {
        private Supplier<T> factory;

        PerSessionServerCallHandler(Supplier<T> factory) {
            this.factory = factory;
        }

        @Override
        @SuppressWarnings("unchecked")
        public ServerCall.Listener startCall(ServerCall call, Metadata headers) {
            UUID sessionId = call.getAttributes().get(SessionIdTransportFilter.SESSION_ID);
            if (sessionId != null) {
                if (!sessionServices.containsKey(sessionId)) {
                    T instance = factory.get();
                    sessionServices.put(sessionId, instance);

                    ServerServiceDefinition definition = instance.bindService();
                    ServerMethodDefinition method = definition.getMethod(call.getMethodDescriptor().getFullMethodName());

                    return method.getServerCallHandler().startCall(call, headers);
                } else {
                    T instance = sessionServices.get(sessionId);
                    ServerServiceDefinition definition = instance.bindService();
                    ServerMethodDefinition method = definition.getMethod(call.getMethodDescriptor().getFullMethodName());

                    return method.getServerCallHandler().startCall(call, headers);
                }
            } else {
                throw new IllegalStateException("SessionIdTransportFilter was not registered with " +
                        "ServerBuilder.addTransportFilter(new SessionIdTransportFilter())");
            }
        }
    }

    private void deactivate(UUID sessionKey) {
        T instance = sessionServices.remove(sessionKey);
        if (instance instanceof AutoCloseable) {
            try {
                ((AutoCloseable) instance).close();
            } catch (Throwable t) {
                throw new RuntimeException(t);
            }
        }
    }
}
